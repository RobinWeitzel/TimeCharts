

<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>JSDoc: index.js</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link href="https://fonts.googleapis.com/css?family=Muli:100,400,700|Oswald:300|Inconsolata,700" rel="stylesheet">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">
    <link type="text/css" rel="stylesheet" href="https://jmblog.github.io/color-themes-for-google-code-prettify/themes/tomorrow-night.min.css">
    <link type="text/css" rel="stylesheet" href="styles/app.min.css">
</head>

<body>
    <div id="stickyNavbarOverlay"></div>
    <div class="top-navbar">
        <div class="container">
            <nav class="navbar" role="navigation" aria-label="main navigation">
                <div class="navbar-brand">
                    
                    
                        <h1 class="navbar-item">Documentation</h1>
                    
                    <a id="hamburger" role="button" class="navbar-burger" aria-label="menu" aria-expanded="false">
                        <span aria-hidden="true"></span>
                        <span aria-hidden="true"></span>
                        <span aria-hidden="true"></span>
                    </a>
                </div>
                
            </nav>
        </div>
    </div>
    <div class="container">
        <div class="columns">
            <div class="column is-3" id="sidebarNav">
                <div class="sidebar">
                    <nav>
                        <h2><a href="index.html">Home</a></h2><div class="category"><h3>Modules</h3><ul><li><a href="module-TimeCharts.html">TimeCharts</a></li></ul><h3>Classes</h3><ul><li><a href="module-TimeCharts-Barchart.html">Barchart</a></li><li><a href="module-TimeCharts-Timeline.html">Timeline</a></li></ul></div>
                    </nav>
                </div>
            </div>
            <div class="column is-9-desktop">
                <div class="content" id="main-content-wrapper">
                    <header class="page-title">
                        <p>Source</p>
                        <h1>index.js</h1>
                    </header>
                    
                    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import style from './index.css';

/**
 * A module to visualize time-related data.
 * @module TimeCharts
 */

///// PRIVATE HELPERS /////

/**
 * Sets multiple attributes for a dom element.
 * @private
 * @param {Object} obj - the dom element
 * @param {Object} params - the attributes to be set
 */
function setAttributes(obj, params) {
    for (const [key, value] of Object.entries(params)) {
        if (key === "class") {
            obj.classList.add(...value);
        } else {
            obj.setAttribute(key, value);
        }
    }
}

/**
 * Removes all child elements from a DOM element.
 * @private
 * @param {Object} obj - the dom element
 */
function clear(obj) {
    while (obj.firstChild) {
        obj.removeChild(obj.firstChild);
    }
}


/**
 * Merges an object into another one.
 * @private
 * @param {Object} obj - the object into which to merge 
 * @param {Object} merger - the object to merge 
 * @param {boolean} [overwrite = false] - whether to overwrite the original value of it exists
 */
function mergeObjects(obj, merger, overwrite) {
    overwrite = overwrite === true; // defaults to false

    for (let key of Object.keys(merger)) {
        if (!(key in obj)) {
            obj[key] = merger[key];
        } else if (typeof merger[key] === "object") {
            mergeObjects(obj[key], merger[key], overwrite);
        } else if (overwrite) {
            obj[key] = merger[key];
        }
    }
}

class Draw {
    /**
     * Creates an svg object.
     * @private
     * @param {number|string} width - width of the svg
     * @param {number|string} height - height of the svg
     * @param {number} vbWidth - width of the viewbox
     * @param {number} vbHeight - height of the viewbox
     * @param {Object} [options] - additional attributes for the svg
     * @returns {Object} - svg object
     */
    static svg(width, height, vbWidth, vbHeight, options) {
        const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg")
        setAttributes(svg, {
            width,
            height,
            viewBox: "0 0 " + vbWidth + " " + vbHeight,
            preserveAspectRatio: "none"
        });
        setAttributes(svg, options || {});
        return svg;
    }

    /**
     * Draws an svg rectangle.
     * @private
     * @param {number} x - x-coordinate
     * @param {number} y - y-coordinate
     * @param {number} width - width of the rectangle
     * @param {number} height - height of the rectangle
     * @param {string} color - the fill color of the rectangle
     * @param {Object} [options] additional attributes for the rectangle
     * @returns {Object} - svg rectangle
     */
    static rect(x, y, width, height, color, options) {
        const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect")
        setAttributes(rect, {
            width,
            height,
            x,
            y,
            fill: color
        });
        setAttributes(rect, options || {});
        return rect;
    }

    /**
     * Draws an svg line.
     * @private
     * @param {number} x1 - x-coordinate where the line begins
     * @param {number} y1 - y-coordinate where the line begins
     * @param {number} x2 - x-coordinate where the line ends
     * @param {number} y2 - y-coordinate where the line begins
     * @param {string} color - color of the line
     * @param {number} width - width of the line
     * @param {Object} [options] - additional attributes for the line
     * @returns {Object} - svg line
     */
    static line(x1, y1, x2, y2, color, width, options) {
        const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
        setAttributes(line, {
            x1,
            y1,
            x2,
            y2,
            stroke: color,
            "stroke-width": width
        });
        setAttributes(line, options || {});
        return line;
    }

    /**
     * Draws an svg path.
     * @private
     * @param {string} shape - the shape of the path 
     * @param {string} color - the color of the path
     * @param {Object} [options] - additional attributes for the path
     * @returns {Object} - svg path
     */
    static path(shape, color, options) {
        const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
        setAttributes(path, {
            d: shape,
            fill: color
        });
        setAttributes(path, options || {});
        return path;
    }

    /**
     * Draws an svg text.
     * @private
     * @param {number} x - x-coordinate of the top right left corner of the text
     * @param {number} y - y-coordinate of the top right left corner of the text
     * @param {string} content - the text that is displayed
     * @param {string} color - the text color
     * @param {string} [font = 'Roboto'] - the font name
     * @param {Object} [options] - additional attributes for the text
     * @returns {Object} - svg text
     */
    static text(x, y, content, color, font, options) {
        color = color || "black";
        font = font || 'Roboto';
        const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
        setAttributes(text, {
            x,
            y,
            "font-size": "14px",
            fill: color,
            stroke: "none",
            "font-family": font,
            "text-anchor": "middle",
            class: ["static"]
        });
        setAttributes(text, options || {});
        text.appendChild(document.createTextNode(content))
        return text;
    }

    /**
     * Creates an svg group.
     * @private
     * @returns {Object} - svg group
     */
    static group() {
        return document.createElementNS("http://www.w3.org/2000/svg", "g");
    }
}

///// PUBLIC FUNCTIONS /////

/**
 * Creates a bar chart
 * @class
 */
class Barchart {
    /**
     * Constructs a bar chart
     * @constructor
     * @param {string} element - css query selector of the container dom element into which the chart is placed.
     * @param {Object} [params] - options
     * @param {Object} [params.barSize = 25] - the size of a bar in px.
     * @param {array} [params.data] - the data to be displayed.
     * @param {string[]} [params.data.labels] - the labels underneath each bar.
     * @param {Object[]} [params.data.datasets] - each dataset represents one "block" of a bar. To create a stacked bar chart have multiple datasets.
     * @param {number[]} params.data.datasets[].values - the values for each "block" of a bar. Should be between 0 and 1. 
     * @param {string} [params.data.datasets[].title] - the title for the dataset.
     * @param {Object} [params.padding] - padding in all directions of the chart.
     * @param {number|string} [params.padding.top] - top padding for the chart.
     * @param {number|string} [params.padding.right] - right padding for the chart.
     * @param {number|string} [params.padding.bottom] - bottom padding for the chart.
     * @param {number|string} [params.padding.left] - left padding for the chart.
     * @param {Object} [params.colors] - custom colors
     * @param {string[]} [params.colors.foreground = ['#7cd6fd', '#5e64ff', '#743ee2', '#ff5858', '#ffa00a', '#feef72', '#28a745', '#98d85b', '#b554ff', '#ffa3ef', '#36114C', '#bdd3e6', '#f0f4f7', '#b8c2cc']] - the colors for each bar.
     * @param {string} [params.colors.background = "#E3E6E9"] - the color of the background of the bars (not the color of background of the whole chart).
     * @param {string} [params.colors.text = "black"] - the color of the text.
     * @param {'vertical' | 'horizontal'} [params.orientation = 'vertical'] - orientation for the chart.
     * @param {string} [params.font = 'Roboto'] - the font for all writing. Font must be imported separately.
     * @param {boolean} [params.hover = true] - whether the titles should be shown on hover or not.
     * @param {'variable' | number} [params.distance = 'variable'] - whether the distance between timelines should be variable (based on svg size) or a fixed number of px.
     * @param {boolean} [params.adjustSize = false] - whether the size of the container should be adjusted based on the needed space. Only works if params.distance != 'variable'.
     * @throws Will throw an error if the container element is not found.
     */
    constructor(element, params) {
        this.container = document.querySelector(element);
        if (this.container == null) {
            console.error("Container for chart does not exist");
            return;
        }

        // Extract parameters and sets defaults if parameters not available
        mergeObjects(params, {
            data: {
                labels: [],
                datasets: []
            },
            padding: {
                top: 0,
                right: 0,
                bottom: 0,
                left: 0
            },
            colors: {
                foreground: ['#7cd6fd', '#5e64ff', '#743ee2', '#ff5858', '#ffa00a', '#feef72', '#28a745', '#98d85b', '#b554ff', '#ffa3ef', '#36114C', '#bdd3e6', '#f0f4f7', '#b8c2cc'],
                background: "#E3E6E9",
                text: "black"
            },
            orientation: "vertical",
            font: "Roboto",
            hover: true,
            barSize: 25,
            distance: 'variable',
            adjustSize: false
        });

        this.data = params.data;
        this.padding = params.padding;
        this.foregroundColors = params.colors.foreground;
        this.backgroundColor = params.colors.background;
        this.textColor = params.colors.text;
        this.orientation = params.orientation;
        this.font = params.font;
        this.hover = params.hover;
        this.barSize = params.barSize;
        this.distance = params.distance;
        this.adjustSize = this.distance !== 'variable' &amp;&amp; params.adjustSize;

        if (this.orientation !== "horizontal") {
            this.drawVertical();

            if(typeof ResizeObserver === "function") {
                const ro = new ResizeObserver(entries => {
                    this.drawVertical();
                });
                ro.observe(this.container);
            } else {
                window.addEventListener('resize', () => {
                    this.drawVertical();
                });
            }
        } else {
            this.drawHorizontal();
            if(typeof ResizeObserver === "function") {
                const ro = new ResizeObserver(entries => {
                    this.drawHorizontal();
                });
                ro.observe(this.container);
            } else {
                window.addEventListener('resize', () => {
                    this.drawHorizontal();
                });
            }
        }
    }

    /**
     * Draws a vertical chart
     * @private
     */
    drawVertical() {
        const realHeight = this.container.clientHeight - this.padding.top - this.padding.bottom;
        const viewboxHeightScale = 100 / realHeight;
        const barCount = this.data.datasets.reduce((p, c) => Math.max(p, c.values.length), 0);
        const barWidth = this.barSize;
        const barHeight = 100 - 25 * viewboxHeightScale;

        if(this.adjustSize) {
            const width = (barWidth+this.distance) * barCount + this.padding.left + this.padding.right;
            this.container.style.width = `${width}px`;
        }
        
        const realWidth = this.container.clientWidth - this.padding.right - this.padding.left;
        const viewboxWidthScale = realWidth / 100;
        const barSpacing = this.distance === 'variable' ? (100 * viewboxWidthScale) / barCount - barWidth : this.distance;
        
        this.svg = Draw.svg(`calc(100% - ${this.padding.right + this.padding.left}px)`, `calc(100% - ${this.padding.top + this.padding.bottom}px)`, 100 * viewboxWidthScale, 100);

        // Padding
        this.svg.style.paddingTop = this.padding.top;
        this.svg.style.paddingRight = this.padding.right;
        this.svg.style.paddingBottom = this.padding.bottom;
        this.svg.style.paddingLeft = this.padding.left;
        this.svg.style.boxSizing = "initial";

        // Draw data
        for (let i = 0; i &lt; barCount; i++) {
            const label = this.data.labels[i] || "";

            const rx = barWidth / 2;
            const ry = barWidth / 2 * viewboxHeightScale;

            const background = Draw.path(
                `M ${(i + 0.5) * barSpacing + i * barWidth},${0} m 0, ${barHeight - ry} a ${rx},${ry} 0 0 0 ${barWidth},0 v ${ry * 2 - barHeight} a ${rx},${ry} 0 0 0 ${-barWidth},0 z`,
                this.backgroundColor
            );
            this.svg.appendChild(background);

            let y = 0; // height of the bar. Contains the position at which to draw the next rectangle

            for (let j = 0; j &lt; this.data.datasets.length; j++) {
                const value = this.data.datasets[j].values[i] || 0;
                const title = this.data.datasets[j].title || "";

                let foreground;
                const height = (barHeight * value);
                const steepness = 0.05; // The smaller, the rounder

                if (this.data.datasets.length === 1) { // single element
                    if(height - ry * 2 &lt; 0) { // bar to short to form circle
                        foreground = Draw.path(
                            `M ${(i + 0.5) * barSpacing + i * barWidth}, ${(barHeight - y) - height/2} c ${barWidth * steepness} ${height/2/0.75}, ${barWidth * (1-steepness)} ${height/2/0.75}, ${barWidth} 0 h ${-barWidth} c ${barWidth * steepness} ${-(height/2/0.75)}, ${barWidth * (1-steepness)} ${-(height/2/0.75)}, ${barWidth} 0 z`,
                            this.foregroundColors[j % this.foregroundColors.length]
                        );
                    } else {
                        foreground = Draw.path(
                            `M ${(i + 0.5) * barSpacing + i * barWidth},${(barHeight - y) - ry} a ${rx},${ry} 0 0 0 ${barWidth},0 v ${ry * 2 - (barHeight * value)} a ${rx},${ry} 0 0 0 ${-barWidth},0 z`,
                            this.foregroundColors[j % this.foregroundColors.length]
                        );
                    }
                } else if (y === 0) { // First element
                    if(height - ry &lt; 0) { // bar to short to form circle
                        foreground = Draw.path(
                            `M ${(i + 0.5) * barSpacing + i * barWidth}, ${(barHeight - y) - height} c ${barWidth * steepness} ${height/0.75}, ${barWidth * (1-steepness)} ${height/0.75}, ${barWidth} 0 z`,
                            this.foregroundColors[j % this.foregroundColors.length]
                        );
                    } else {
                        foreground = Draw.path(
                            `M ${(i + 0.5) * barSpacing + i * barWidth},${(barHeight - y) - ry} a ${rx},${ry} 0 0 0 ${barWidth},0 v ${ry - (barHeight * value)} h ${-barWidth} z`,
                            this.foregroundColors[j % this.foregroundColors.length]
                        );
                    }
                } else if (y + barHeight * value === barHeight || j === this.data.datasets.length - 1) { // Last element
                    if(height - ry &lt; 0) { // bar to short to form circle
                        foreground = Draw.path(
                            `M ${(i + 0.5) * barSpacing + i * barWidth}, ${(barHeight - y)} c ${barWidth * steepness} ${-(height/0.75)}, ${barWidth * (1-steepness)} ${-(height/0.75)}, ${barWidth} 0 z`,
                            this.foregroundColors[j % this.foregroundColors.length]
                        );
                    } else {
                        foreground = Draw.path(
                            `M ${(i + 0.5) * barSpacing + i * barWidth},${barHeight - y} h ${barWidth} v ${ry - (barHeight * value)} a ${rx},${ry} 0 0 0 ${-barWidth},0 z`,
                            this.foregroundColors[j % this.foregroundColors.length]
                        );
                    }
                } else { // element in the middle
                    foreground = Draw.path(
                        `M ${(i + 0.5) * barSpacing + i * barWidth},${barHeight - y} h ${barWidth} v ${-barHeight * value} h ${-barWidth} z`,
                        this.foregroundColors[j % this.foregroundColors.length]
                    );
                }

                if (this.hover) {
                    foreground.addEventListener('mouseenter', evt => { this.showTooltip(true, foreground, value, title) });
                    foreground.addEventListener("mouseleave", evt => { this.showTooltip(false) });
                }

                if (y &lt; barHeight) { // only draw the part if it would not overshoot
                    this.svg.appendChild(foreground);
                }

                y = y + barHeight * value;
            }

            const text = Draw.text((i + 0.5) * (barSpacing + barWidth), barHeight + (20 * viewboxHeightScale), label, this.textColor, this.font);
            text.setAttribute("transform", `scale(1,${viewboxHeightScale}) translate(0, ${parseFloat(text.getAttribute("y")) / viewboxHeightScale - parseFloat(text.getAttribute("y"))})`);
            this.svg.appendChild(text);
        }

        clear(this.container);
        this.tooltip = undefined;
        this.container.appendChild(this.svg);
    }

    /**
     * Draws a horizontal chart
     * @private
     */
    drawHorizontal() {
        const realWidth = this.container.clientWidth - this.padding.right - this.padding.left;
        const viewboxWidthScale = 100 / realWidth;
        const barCount = this.data.datasets.reduce((p, c) => Math.max(p, c.values.length), 0);
        const textWidth = this.data.labels.reduce((p, c) => Math.max(p, c.length > 0 ? (2 + c.length * 7.5) * viewboxWidthScale : 0), 0); // 7.5 per char 
        const barWidth = 100 - textWidth;
        const barHeight = this.barSize;
        
        if(this.adjustSize) {
            const height = (barCount + this.distance) * barHeight + this.padding.top + this.padding.bottom;
            this.container.style.height = `${height}px`;
        }
        
        const realHeight = this.container.clientHeight - this.padding.top - this.padding.bottom;
        const viewboxHeightScale = realHeight / 100;
        const barSpacing = this.distance === 'variable' ? (100 * viewboxHeightScale) / barCount - barHeight : this.distance;
        
        this.svg = Draw.svg(`calc(100% - ${this.padding.right + this.padding.left}px)`, `calc(100% - ${this.padding.top + this.padding.bottom}px)`, 100, 100 * viewboxHeightScale);

        // Padding
        this.svg.style.paddingTop = this.padding.top;
        this.svg.style.paddingRight = this.padding.right;
        this.svg.style.paddingBottom = this.padding.bottom;
        this.svg.style.paddingLeft = this.padding.left;
        this.svg.style.boxSizing = "initial";

        // Draw data
        for (let i = 0; i &lt; barCount; i++) {
            const label = this.data.labels[i] || "";

            const rx = barHeight / 2 * viewboxWidthScale;
            const ry = barHeight / 2;

            const background = Draw.path(
                `M ${textWidth + rx}, ${(i + 0.5) * barSpacing + i * barHeight} a ${rx},${ry} 0 0 0 0,${barHeight} h ${barWidth - rx * 2} a ${rx},${ry} 0 0 0 0,${-barHeight} z`,
                "#E3E6E9"
            );
            this.svg.appendChild(background);

            let x = 0; // width of the bar. Contains the position at which to draw the next rectangle

            for (let j = 0; j &lt; this.data.datasets.length; j++) {
                const value = this.data.datasets[j].values[i] || 0;
                const title = this.data.datasets[j].title || "";

                let foreground;
                const width = (barWidth * value);
                const steepness = 0.05; // The smaller, the rounder
                if (this.data.datasets.length === 1) { // single element
                    if(width - rx * 2 &lt; 0) { // bar to short to form circle
                        foreground = Draw.path(
                            `M ${textWidth + x + width/2}, ${(i + 0.5) * barSpacing + i * barHeight} c ${-(width/2 / 0.75)} ${barHeight * steepness}, ${-(width/2 / 0.75)} ${barHeight * (1-steepness)}, 0 ${barHeight} v ${-barHeight} c ${width/2/0.75} ${barHeight * steepness}, ${width/2/0.75} ${barHeight * (1-steepness)}, 0 ${barHeight} z`,
                            this.colors[j % this.colors.length]
                        );
                    } else {
                        foreground = Draw.path(
                            `M ${textWidth + x + rx},${(i + 0.5) * barSpacing + i * barHeight} a ${rx},${ry} 0 0 0 0,${barHeight} h ${(barWidth * value) - rx * 2} a ${rx},${ry} 0 0 0 0,${-barHeight} z`,
                            this.colors[j % this.colors.length]
                        );
                    }
                } else if (x === 0) { // First element
                    if(width - rx  &lt; 0) { // bar to short to form circle
                        foreground = Draw.path(
                            `M ${textWidth + x + width}, ${(i + 0.5) * barSpacing + i * barHeight} c ${-(width/0.75)} ${barHeight * steepness}, ${-(width/0.75)} ${barHeight * (1-steepness)}, 0 ${barHeight} z`,
                            this.colors[j % this.colors.length]
                        );
                    } else {
                        foreground = Draw.path(
                            `M ${textWidth + x + rx},${(i + 0.5) * barSpacing + i * barHeight} a ${rx},${ry} 0 0 0 0,${barHeight} h ${(barWidth * value) - rx} v ${-barHeight} z`,
                            this.colors[j % this.colors.length]
                        );
                    }
                } else if (x + barWidth * value === barWidth || j === this.data.datasets.length - 1) { // Last element
                    if(width - rx  &lt; 0) { // bar to short to form circle
                        foreground = Draw.path(
                            `M ${textWidth + x}, ${(i + 0.5) * barSpacing + i * barHeight} c ${width/0.75} ${barHeight * steepness}, ${width/0.75} ${barHeight * (1-steepness)}, 0 ${barHeight} z`,
                            this.colors[j % this.colors.length]
                        );
                    } else {
                        foreground = Draw.path(
                            `M ${textWidth + x},${(i + 0.5) * barSpacing + i * barHeight} v ${barHeight} h ${(barWidth * value) - rx} a ${rx},${ry} 0 0 0 0,${-barHeight} z`,
                            this.colors[j % this.colors.length]
                        );
                    }
                } else { // element in the middle
                    foreground = Draw.path(
                        `M ${textWidth + x}, ${(i + 0.5) * barSpacing + i * barHeight} v ${barHeight} h ${barWidth * value} v ${-barHeight} z`,
                        this.colors[j % this.colors.length]
                    );
                }

                if (this.hover) {
                    foreground.addEventListener('mouseenter', evt => { this.showTooltip(true, foreground, value, title) });
                    foreground.addEventListener("mouseleave", evt => { this.showTooltip(false) });
                }

                if (x &lt; barWidth) { // only draw the part if it would not overshoot
                    this.svg.appendChild(foreground);
                }

                x = x + barWidth * value;
            }

            const text = Draw.text(0, (i + 0.5) * (barSpacing + barHeight), label, "black", this.font, { "text-anchor": "start", "alignment-baseline": "central" });
            text.setAttribute("transform", `scale(${viewboxWidthScale},1) translate(${parseFloat(text.getAttribute("x")) / viewboxWidthScale - parseFloat(text.getAttribute("x"))}, 0)`);
            this.svg.appendChild(text);
        }

        clear(this.container);
        this.tooltip = undefined;
        this.container.appendChild(this.svg);
    }

    /**
     * Draws a tooltip at the horizontal center of the element
     * @private
     * @param {boolean} show - Whether to show or hide the tooltip
     * @param {Object} g - the element on which the tooltip is centered
     * @param {number|string} value - the value of the element
     * @param {number|string} title - the title of the element
     */
    showTooltip(show, g, value, title) {
        if (this.tooltip === undefined) {
            this.tooltip = document.createElement('div');
            this.tooltip.style.display = "block";
            this.tooltip.style.position = "absolute";
            this.tooltip.style.fontFamily = this.font;
            this.tooltip.classList.add('time-chart-tooltip');
            this.tooltip.appendChild(document.createElement('span'));
            this.container.appendChild(this.tooltip);
        }

        if (!show) {
            this.tooltip.style.visibility = "hidden";
            return;
        }

        clear(this.tooltip);
        this.tooltip.innerHTML = `&lt;span style="color: gray">${value}&lt;/span>${title !== "" ? ": " + title : ""}`;
        this.tooltip.style.top = g.getBoundingClientRect().y - 43 + "px";
        this.tooltip.style.left = `calc(${g.getBoundingClientRect().x + g.getBoundingClientRect().width / 2 - this.tooltip.getBoundingClientRect().width / 2}px)`;
        this.tooltip.style.visibility = "visible";
    }

    /**
     * Replaces the existing data with new data.
     * @param {array} [data] - the data to be displayed
     * @param {string[]} [data.labels] - the labels underneath each bar
     * @param {Object[]} [data.datasets] - each dataset represents one "block" of a bar. To create a stacked bar chart have multiple datasets.
     * @param {number[]} data.datasets[].values - the values for each "block" of a bar. Should be between 0 and 1. 
     * @param {string} [data.datasets[].title] - the title for the dataset.
     */
    setData(data) {
        this.data = data;
        if (this.orientation !== "horizontal") {
            this.drawVertical();
        } else {
            this.drawHorizontal();
        }
    }
}

/**
 * Creates a timeline
 * @class
 */
class Timeline {
    /**
     * Constructs a timeline
     * @constructor
     * @param {string} element - css query selector of the container dom element into which the chart is placed.
     * @param {Object} [params] - options.
     * @param {Object} [params.lineHeight = 25] - the hight of a bar in a timeline in px.
     * @param {Object} [params.scale] - options for the scale at the top of the timelines
     * @param {number} [params.scale.from = 0] - the time in minutes at which the timeline should start.
     * @param {number} [params.scale.to = 1440] - the time in minutes at which the timeline should end.
     * @param {number} [params.scale.interval = 240] - the interval at which labels are shown on the scale.
     * @param {number} [params.scale.intervalStart = 0] - the point at which the interval starts counting.
     * @param {array} [params.data] - the data to be displayed.
     * @param {Object[]} [params.data.timelines] - each object represents one timeline. For multiple timelines under each other, have multiple objects.
     * @param {string} [params.data.timelines[].label] - the label to the right of the timeline.
     * @param {Object[]} params.data.timelines[].values - the values (marked time slots).
     * @param {number} params.data.timelines[].values[].start - the point at which the time slot starts in minutes.
     * @param {number} params.data.timelines[].values[].length - the point at which the time slot ends in minutes.
     * @param {string} [params.data.timelines[].values[].title] - the title of the time slot.
     * @param {string[]} [params.data.timelines[].colors = ['#7cd6fd', '#5e64ff', '#743ee2', '#ff5858', '#ffa00a', '#feef72', '#28a745', '#98d85b', '#b554ff', '#ffa3ef', '#36114C', '#bdd3e6', '#f0f4f7', '#b8c2cc']] - the colors for the timeline.
     * @param {Object} [params.padding] - padding in all directions of the chart.
     * @param {number|string} [params.padding.top] - top padding for the chart.
     * @param {number|string} [params.padding.right] - right padding for the chart.
     * @param {number|string} [params.padding.bottom] - bottom padding for the chart.
     * @param {number|string} [params.padding.left] - left padding for the chart.
     * @param {Object} [params.colors] - custom colors
     * @param {string} [params.colors.background = "#E3E6E9"] - the color of the background of the bars (not the color of background of the whole chart).
     * @param {string} [params.colors.text = "black"] - the color of the text.
     * @param {string} [params.font = 'Roboto'] - the font for all writing. Font must be imported separately.
     * @param {boolean} [params.hover = true] - whether the titles should be shown on hover or not.
     * @param {Object} [params.legend] - options for the legend.
     * @param {boolean} [params.legend.visible = true] - whether a legend should be shown underneath the timelines.
     * @param {number} [params.legend.distance = 15] - distance from the last timeline to the legend in px. Always set to 0 if params.legend.visible === false.
     * @param {number} [params.legend.textColor = "white"] - the color of the text in the legend.
     * @param {'variable' | number} [params.distance = 'variable'] - whether the distance between timelines should be variable (based on svg size) or a fixed number of px.
     * @param {boolean} [params.adjustSize = false] - whether the size of the container should be adjusted based on the needed space. Only works if params.distance != 'variable'.
     * @throws Will throw an error if the container element is not found.
     */
    constructor(element, params) {
        this.container = document.querySelector(element);
        if (this.container == null) {
            console.error("Container for chart does not exist");
            return;
        }

        // Extract parameters and sets defaults if parameters not available
        mergeObjects(params, {
            scale: {
                from: 0,
                to: 1440,
                interval: 240,
                intervalStart: 0
            },
            data: {
                timelines: [],
            },
            padding: {
                top: 0,
                right: 0,
                bottom: 0,
                left: 0
            },
            colors: {
                background: "#E3E6E9",
                text: "black"
            },
            font: "Roboto",
            hover: true,
            legend: {
                visible: true,
                distance: 15,
                textColor: "white"
            },
            lineHeight: 25,
            distance: 'variable',
            adjustSize: false
        });

        this.scale = params.scale;
        this.data = params.data;
        this.padding = params.padding;
        this.font = params.font;
        this.hover = params.hover;
        this.legend = params.legend.visible;
        this.legendDistance = params.legend.distance;
        this.legendTextColor = params.legend.textColor;
        this.lineHeight = params.lineHeight;
        this.distance = params.distance;
        this.adjustSize = this.distance !== 'variable' &amp;&amp; params.adjustSize;
        this.backgroundColor = params.colors.background;
        this.textColor = params.colors.text;

        this.draw();
        if(typeof ResizeObserver === "function") {
            const ro = new ResizeObserver(entries => {
                this.draw();
            });
            ro.observe(this.container);
        } else {
            window.addEventListener('resize', () => {
                this.draw();
            });
        }
    }

    /**
     * Draws the timeline
     * @private
     */
    draw() {
        const realWidth = this.container.clientWidth - this.padding.right - this.padding.left;
        const viewboxWidthScale = 100 / realWidth;
        const lineCount = this.data.timelines.length;
        const textWidth1 = this.data.timelines.reduce((p, c) => Math.max(p, c.label.length > 0 ? (40 + c.label.length * 7.5) * viewboxWidthScale : 0), 0); // 7.5 per char 
        const textWidth2 = this.data.timelines.reduce((p, c) => Math.max(p, c.values.reduce((p, c) => Math.max(p, (10 + this.formatMinutes(c.length).length * 7.5) * viewboxWidthScale), 0)), 0); // 7.5 per char
        const widthLeft = Math.max(textWidth1 + textWidth2, 20 * viewboxWidthScale);
        const widthRight = 20 * viewboxWidthScale;
        const scaleHeight = 20;
        const lineWidth = 100 - widthLeft - widthRight;
        const lineHeight = this.lineHeight;
        const legendHeight = this.legend ? lineHeight : 0;
        const legendSpacing = this.legend ? this.legendDistance : 0;

        if(this.adjustSize) {
            const height = scaleHeight + legendHeight + legendSpacing + lineCount * (lineHeight + this.distance) + this.padding.top + this.padding.bottom;
            this.container.style.height = `${height}px`;
        }

        const realHeight = this.container.clientHeight - this.padding.top - this.padding.bottom;
        const viewboxHeightScale = realHeight / 100;
        const lineSpacing = this.distance === 'variable' ? (100 * viewboxHeightScale - scaleHeight - legendHeight - legendSpacing) / lineCount - lineHeight : this.distance;
        const scaleStart = Math.max(0.5 * lineSpacing - scaleHeight, 0);

        this.svg = Draw.svg(`calc(100% - ${this.padding.right + this.padding.left}px)`, `calc(100% - ${this.padding.top + this.padding.bottom}px)`, 100, 100 * viewboxHeightScale);

        // Padding
        this.svg.style.paddingTop = this.padding.top;
        this.svg.style.paddingRight = this.padding.right;
        this.svg.style.paddingBottom = this.padding.bottom;
        this.svg.style.paddingLeft = this.padding.left;
        this.svg.style.boxSizing = "initial";

        // Draw scale
        const from = this.scale.from;
        const to = this.scale.to;
        const interval = this.scale.interval;
        const intervalStart = (this.scale.intervalStart) / (to - from) * lineWidth;
        const intervalSteps = Math.floor((to - from) / interval);
        const intervalStepsWidth = lineWidth / intervalSteps;

        for (let i = 0; i &lt;= intervalSteps; i++) {
            const text = Draw.text(widthLeft + intervalStart + i * intervalStepsWidth, scaleStart, this.formatMinutes2(from + this.scale.intervalStart + i * interval), this.textColor, this.font, { "text-anchor": "middle", "alignment-baseline": "text-before-edge" });
            text.setAttribute("transform", `scale(${viewboxWidthScale},1) translate(${parseFloat(text.getAttribute("x")) / viewboxWidthScale - parseFloat(text.getAttribute("x"))}, 0)`);
            this.svg.appendChild(text);
        }

        let x = 0;

        // Draw data
        for (let i = 0; i &lt; lineCount; i++) {
            const label = this.data.timelines[i].label || "";
            const values = this.data.timelines[i].values || [];
            const colors = this.data.timelines[i].colors || ['#7cd6fd', '#5e64ff', '#743ee2', '#ff5858', '#ffa00a', '#feef72', '#28a745', '#98d85b', '#b554ff', '#ffa3ef', '#36114C', '#bdd3e6', '#f0f4f7', '#b8c2cc'];
            const valueMap = {}; // Helper to calculate grouped values and store color codes
            const sum = this.data.timelines[i].values.reduce((p, c) => p + c.length, 0);

            const rx = lineHeight / 2 * viewboxWidthScale;
            const ry = lineHeight / 2;

            // Draw background
            // Gray background
            const background = Draw.path(
                `M ${widthLeft + rx}, ${scaleStart + scaleHeight + i * (lineSpacing + lineHeight)} a ${rx},${ry} 0 0 0 0,${lineHeight} h ${lineWidth - rx * 2} a ${rx},${ry} 0 0 0 0,${-lineHeight} z`,
                this.backgroundColor
            );
            this.svg.appendChild(background);

            // White stripes each hour
            const steps = (to - from) / 60;
            const stepWidth = lineWidth / steps;

            for (let j = 1; j &lt; steps; j++) {
                const rect = Draw.rect(widthLeft + j * stepWidth - (1 * viewboxWidthScale), scaleStart + scaleHeight + i * (lineSpacing + lineHeight), (2 * viewboxWidthScale), lineHeight, "white");
                this.svg.appendChild(rect);
            }

            // Draw foreground
            for (let j = 0; j &lt; values.length; j++) {
                const relativeStart = (Math.max(0, values[j].start - from) / (to - from));
                const relativeLength = (Math.max(0, values[j].start - from + values[j].length) / (to - from));
                const title = values[j].title || "";

                let color = "";

                if (!(title in valueMap)) { // sub-category has not be encountered before
                    color = colors[Object.keys(valueMap).length % colors.length];
                    valueMap[title] = {
                        color: color,
                        value: values[j].length
                    }
                } else {
                    color = valueMap[title].color;
                    valueMap[title].value = valueMap[title].value + values[j].length;
                }

                let foreground;
                const width = (lineWidth * (relativeLength - relativeStart));

                const polarToCartesian = (centerX, centerY, radius, angleInDegrees) => {
                    const angleInRadians = (angleInDegrees-90) * Math.PI / 180.0;
                  
                    return {
                      x: centerX + (radius * Math.cos(angleInRadians)),
                      y: centerY + (radius * Math.sin(angleInRadians))
                    };
                }

                const partialCircle = (x, y, radius, startAngle, endAngle) => {
                  
                      const start = polarToCartesian(x, y, radius, endAngle);
                      const end = polarToCartesian(x, y, radius, startAngle);
                  
                      const largeArcFlag = endAngle - startAngle &lt;= 180 ? "0" : "1";
                  
                      const d = [
                          "M", start.x, start.y, 
                          "A", radius, radius, 0, largeArcFlag, 0, end.x, end.y,
                          "L", 
                      ].join(" ");
                  
                      return d;       
                  }
                const steepness = 0.05; // The smaller, the rounder

                if(width - rx * 2 &lt; 0) { // bar to short to form circle
                    foreground = Draw.path(
                        `M ${widthLeft + lineWidth * relativeStart + width/2}, ${scaleStart + scaleHeight + i * (lineSpacing + lineHeight)} c ${-(width/2 / 0.75)} ${lineHeight * steepness}, ${-(width/2 / 0.75)} ${lineHeight * (1-steepness)}, 0 ${lineHeight} v ${-lineHeight} c ${width/2/0.75} ${lineHeight * steepness}, ${width/2/0.75} ${lineHeight * (1-steepness)}, 0 ${lineHeight} z`,
                        color
                    );
                } else {
                    foreground = Draw.path(
                        `M ${widthLeft + lineWidth * relativeStart + rx},${scaleStart + scaleHeight + i * (lineSpacing + lineHeight)} a ${rx},${ry} 0 0 0 0,${lineHeight} h ${(lineWidth * (relativeLength - relativeStart)) - rx * 2} a ${rx},${ry} 0 0 0 0,${-lineHeight} z`,
                        color
                    );
                }
                this.svg.appendChild(foreground);

                if (this.hover) {
                    foreground.addEventListener('mouseenter', evt => { this.showTooltip(true, foreground, values[j].start, values[j].start + values[j].length, title) });
                    foreground.addEventListener("mouseleave", evt => { this.showTooltip(false) });
                }
            }

            // Draw label
            const text = Draw.text(0.5 * textWidth1, scaleStart + scaleHeight + i * lineSpacing + (i + 0.5) * lineHeight, label, this.textColor, this.font, { "text-anchor": "middle", "alignment-baseline": "central", "font-weight": "bold" });
            text.setAttribute("transform", `scale(${viewboxWidthScale},1) translate(${parseFloat(text.getAttribute("x")) / viewboxWidthScale - parseFloat(text.getAttribute("x"))}, 0)`);
            this.svg.appendChild(text);

            // Draw sum
            const text2 = Draw.text(textWidth1, scaleStart + scaleHeight + i * lineSpacing + (i + 0.5) * lineHeight, this.formatMinutes(sum), this.textColor, this.font, { "text-anchor": "start", "alignment-baseline": "central" });
            text2.setAttribute("transform", `scale(${viewboxWidthScale},1) translate(${parseFloat(text2.getAttribute("x")) / viewboxWidthScale - parseFloat(text2.getAttribute("x"))}, 0)`);
            this.svg.appendChild(text2);

            // Draw legend
            if (this.legend) {
                for (let key of Object.keys(valueMap)) {
                    const content = `${key} - ${this.formatMinutes(valueMap[key].value)}`;
                    const width = (content.length * 7.5 * viewboxWidthScale) + 2 * rx;
                    const legend = Draw.path(
                        `M ${widthLeft + x + rx},${scaleStart + legendSpacing + scaleHeight + (lineCount - 1) * lineSpacing + lineCount * lineHeight} a ${rx},${ry} 0 0 0 0,${legendHeight} h ${width - rx * 2} a ${rx},${ry} 0 0 0 0,${-legendHeight} z`,
                        valueMap[key].color
                    );
                    this.svg.appendChild(legend);

                    const text = Draw.text(widthLeft + x + 0.5 * width, scaleStart + legendSpacing + legendHeight * 0.5 + scaleHeight + (lineCount - 1) * lineSpacing + lineCount * lineHeight, content, this.legendTextColor, this.font, { "text-anchor": "middle", "alignment-baseline": "central" });
                    text.setAttribute("transform", `scale(${viewboxWidthScale},1) translate(${parseFloat(text.getAttribute("x")) / viewboxWidthScale - parseFloat(text.getAttribute("x"))}, 0)`);
                    this.svg.appendChild(text);

                    x = x + width + 10 * viewboxWidthScale; // previous x, width of the rectangle and padding
                }
            }

        }

        clear(this.container);
        this.tooltip = undefined;
        this.container.appendChild(this.svg);
    }

    /**
     * Converts a number of minutes into a string
     * @private
     * @param {number} minutes - the minutes
     * @returns {string} - format: 4h 35m
     */
    formatMinutes(minutes) {
        const h = Math.floor(minutes / 60);
        const m = Math.floor(minutes % 60);

        if (m === 0 &amp;&amp; h === 0) {
            return "";
        } else if (m === 0) {
            return `${h}h`;
        } else if (h === 0) {
            return `${m}m`;
        } {
            return `${h}h ${m}m`;
        }
    }

    /**
     * Converts a number of minutes into a string
     * @private
     * @param {number} minutes - the minutes
     * @returns {string} - format: 4:30 am
     */
    formatMinutes2(minutes) {
        let h = Math.floor(minutes / 60);
        let ending = "am";
        const m = Math.floor(minutes % 60);

        if (h > 12) {
            ending = "pm";
            h = h - 12;
        }

        if (m === 0) {
            return `${h} ${ending}`;
        } else {
            return `${h}:${m &lt; 10 ? m + "0" : m} ${ending}`;
        }
    }

    /**
     * Draws a tooltip at the horizontal center of the element
     * @private
     * @param {boolean} show - Whether to show or hide the tooltip
     * @param {Object} g - the element on which the tooltip is centered
     * @param {number} start - the start value in minutes
     * @param {number} end - the vend value in minutes
     * @param {number|string} title - the title of the element
     */
    showTooltip(show, g, start, end, title) {
        if (this.tooltip === undefined) {
            this.tooltip = document.createElement('div');
            this.tooltip.style.display = "block";
            this.tooltip.style.position = "absolute";
            this.tooltip.style.fontFamily = this.font;
            this.tooltip.classList.add('time-chart-tooltip');
            this.tooltip.appendChild(document.createElement('span'));
            this.container.appendChild(this.tooltip);
        }

        if (!show) {
            this.tooltip.style.visibility = "hidden";
            return;
        }

        this.tooltip.style.top = g.getBoundingClientRect().y - 43 + "px";
        clear(this.tooltip);
        this.tooltip.innerHTML = `&lt;span style="color: gray">${this.formatMinutes2(start)} - ${this.formatMinutes2(end)}&lt;/span>${title !== "" ? ": " + title : ""}`;
        this.tooltip.style.left = `calc(${g.getBoundingClientRect().x + g.getBoundingClientRect().width / 2 - this.tooltip.getBoundingClientRect().width / 2}px)`;
        this.tooltip.style.visibility = "visible";
    }

    /**
     * Replaces the existing data with new data. 
     * @param {array} [params.data] - the data to be displayed.
     * @param {Object[]} [params.data.timelines] - each object represents one timeline. For multiple timelines under each other, have multiple objects.
     * @param {string} [params.data.timelines[].label] - the label to the right of the timeline.
     * @param {Object[]} params.data.timelines[].values - the values (marked time slots).
     * @param {number} params.data.timelines[].values[].start - the point at which the time slot starts in minutes.
     * @param {number} params.data.timelines[].values[].length - the point at which the time slot ends in minutes.
     * @param {string} [params.data.timelines[].values[].title] - the title of the time slot.
     * @param {string[]} [params.data.timelines[].colors = ['#7cd6fd', '#5e64ff', '#743ee2', '#ff5858', '#ffa00a', '#feef72', '#28a745', '#98d85b', '#b554ff', '#ffa3ef', '#36114C', '#bdd3e6', '#f0f4f7', '#b8c2cc']] - the colors for the timeline.
     * @param {Object} [params.padding] - padding in all directions of the chart.
     */
    setData(data) {
        this.data = data;
        this.draw();
    }
}

// attach properties to the exports object to define
// the exported module properties.
export {
    Barchart,
    Timeline
}</code></pre>
        </article>
    </section>




                </div>
            </div>
        </div>
    </div>

<footer class="footer">
    <div class="content has-text-centered">
        <p>Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.3</a> on Mon Aug 19 2019 08:52:33 GMT+0200 (GMT+02:00)</p>
        <p class="sidebar-created-by">
            <a href="https://github.com/SoftwareBrothers/better-docs" target="_blank">BetterDocs theme</a> provided with <i class="fas fa-heart"></i> by 
            <a href="http://softwarebrothers.co" target="_blank">SoftwareBrothers</a>
        </p>
    </div>
</footer>

<script> prettyPrint(); </script>
<script src="scripts/app.min.js"></script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
